# inkfish
A forward proxy for machines, with access control lists

[![Build Status](https://travis-ci.org/bsycorp/inkfish.svg?branch=master)](https://travis-ci.org/bsycorp/inkfish)

https://hub.docker.com/r/bsycorp/inkfish

## About

This is a non-caching forward (aka egress/outbound) proxy, used to implement URL 
white-listing for applications. 

Key features:

* An outbound proxy designed for machines
* Can use cloud metadata to determine the identity of an instance
* Can use Proxy-Authorization header to identify "non-instance" (e.g. codebuild, serverless) workload
* Per-instance, per-user URL white-lists
* TLS MITM by default, white-lists all requests at the URL level
* Optional MITM bypass, by host

## Command-line arguments

```
$ ./inkfish -h
Usage of ./inkfish:
  -addr string
    	proxy listen address (default ":8080")
  -cacert string
    	path to CA cert file (default "ca.pem")
  -cakey string
    	path to CA key file (default "ca.key.pem")
  -config string
    	path to configuration files (default ".")
  -metadata string
    	default metadata provider (aws,none) (default "aws")
  -v	should every proxy request be logged to stdout
```

## Configuration file format

The `-config` argument supplies a path to a directory full of "access control lists" and password file
entries. 

### Passwd files

Passwd files in the config directory must have a `.passwd` extension. They may contain one or more 
lines of: `<username>:<sha256-of-password>` and will be used to verify proxy auth.

It is expected that passwords will generated by infracode / orchestration and have high entropy so
a heavyweight password hashing function is not required.

### ACL Files

ACL files in the config directory must have a `.conf` extension. These control what requests will 
be allowed through the proxy. The general format looks like:

```
from <user> [user2 user3...]
from ...
acl [METHOD,METHOD2] <url-regex>
acl ...
bypass <host-port-regex>
bypass ...
```

Blank lines and comments (lines starting with `#`) are ignored. The `from` lines gate entry into the ACL.
The <user> may be specified as:

* `user:foo` - Identifies a client who will supply a proxy-authorization header with a username of `foo`.
* `tag:foo` - Identifies a client whose cloud metadata (e.g. instance ProxyUser tag in AWS) is `foo`.
* `ANONYMOUS` - Identifies a user or system which does not supply a proxy-authorization header and 
               does not have any identifying metadata tags.

The `acl` directive is used to permit requests according to a regular expression matching a URL.. You 
may optionally specify one or more methods in the ACL, causing only requests made with one of the listed 
methods to match the ACL. Typical "whole-host" acls look like:

* `acl ^http(s)?://foo\.com/`

WARNING: it is generally a mistake to forget the trailing `/`, as this would cause the regular expression
to match things like `https://foo.com.au/evilthing` as well as the intended domain `https://foo.com/`. 
Similarly, it is usually a mistake to forget to escape dots with backslashes as this can also cause 
unintended matches.

A more complex acl example might look like:

* `acl HEAD,GET,POST ^http(s)://api\.foo\.com/v2/

The `bypass` directive is used to disable TLS MITM for specific hosts. You should supply a regular 
expression which can be matched directly against the client's CONNECT request. For example:

* `bypass ^my-super-bucket\.ap-southeast-2\.amazonaws\.com:443$`

## Metadata lookup

Rather than distributing proxy credentials, the preferred method of access control in inkfish is via
cloud instance metadata. 

### AWS

For AWS, specify the `ProxyUser` tag on an instance. So for example if you apply tag of ProxyUser=foo,
then in your ACL you would write:

```
from tag:foo
acl ^http(s)?://.*$
```

To grant instances with that tag unrestricted outbound HTTP(s) access.

## Known issues / TODO

* Generated certs for sites expire in 2049(!)
* Graceful shutdown / draining not tested

